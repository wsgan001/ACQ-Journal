\subsection{Edge Deletion}
\label{sec:edgeDeletion}

Similar to the edge insertion, deleting an edge may trigger the updates of CL-tree nodes as well as their structures. We illustrate this by Example~\ref{ep:deleteExample}.

\begin{example}
\label{ep:deleteExample}
Consider the graph in Figure~\ref{fig:connectivity}. If we delete an edge ($H$, $G$) of the graph in Figure~\ref{fig:advancedIndex}, the core number of vertex $H$ decreases to 1. Thus we need to create a new node with core number being 1 and then move $H$ up to the new node. If we delete an edge ($G$, $I$), the connectivity of some vertices changes as shown in Figure~\ref{fig:advancedIndex} and thus the corresponding subtree has to be split to two new ones.
\end{example}
To maintain the CL-tree for deleting an edge, we propose an algorithm called {\tt deleteEdge}.
Let $V^-$ be the set of vertices whose core numbers decrease after deleting an edge ($u$, $v$).
We summarize the main steps of {\tt deleteEdge} as follows.

$\bullet$ \textbf{Step 1:} Compute $V^-$;

$\bullet$ \textbf{Step 2:} Split the subtree;

$\bullet$ \textbf{Step 3:} Move up vertices of $V^-$.

We now elaborate these steps one by one.

\textbf{Step 1: Compute $V^-$.}
By Lemma~\ref{lm:kcorelemma}, the core numbers of vertices in $G$ decrease by at most 1 after deleting an edge.
We compute $V^-$ using the algorithm in~\cite{kcoreUpdate}.

\textbf{Step 2: Split the subtree.}
Similar to edge insertion, the connectivity of vertices may change after deleting an edge. We illustrate this by Example~\ref{ep:delete}. 

\begin{example}
\label{ep:delete}
Figure~\ref{fig:splitExmp} presents two 2-$\widehat{core}$s. After deleting an edge ($u,v$), the graph in Figure~\ref{fig:split1} is still a 2-$\widehat{core}$; however, the graph in Figure~\ref{fig:split2} is split to two disconnected 2-$\widehat{core}$s.
\end{example}

\begin{figure}[ht]
    \centering
    \mbox{
        \subfigure[]{
            \includegraphics[width=.335\columnwidth]{figures/splitExmp1}
            \label{fig:split1}
        }
        \hspace{2ex}
        \subfigure[]{
            \includegraphics[width=.335\columnwidth]{figures/splitExmp2}
            \label{fig:split2}
        }
    }
    \caption{The connectivity change.}
    \label{fig:splitExmp}
\end{figure}

Inspired by Example~\ref{ep:delete}, we need to reorganize the subgraph and determine whether the subtree will be split after deleting the edge ($u, v$). Instead of rebuilding the subtree, here we dynamically update the subtree in a bottom-up manner starting from the node $p$ ($p.getCore$ = min\{$core_G[u], core_G[v]$\}). We first introduce a vertex-tree map. The key of this map is a vertex, and corresponding value is the root node of one subtree. We illustrate the map in Example~\ref{em:reorganize}. 


%Moreover, if this node is split to two nodes, the father node of this node is also possible to be split because of the new child node. Thus we need to split the subtree level by level until no node needs to be split.
%Let the tree node be $p$ which $u$ and $v$ belong to.
%We first give an observation: If $p$ is a leaf node, vertices in $p$ form a $k$-$\widehat{core}$. If $p$ is a non-leaf node, vertices in $p$ are not necessarily connected from each other. See Figure~\ref{fig:cktree}, vertices $F, G$ in $r_1$ are not directly connected because the CL-tree is compressed.
%Based on the observation, we summarize that vertices which form a tree node should satisfy the following conditions:

%$\bullet$ Vertices in a connected component.

%$\bullet$ Vertices share the same child node.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\linewidth]{figures/traceChild}
    \caption{The vertex-tree map.}
    \label{fig:trace}
\end{figure}


\begin{example}
\label{em:reorganize}
Consider the subtree shown in Figure~\ref{fig:trace}, let $x,y$ denote two vertices of the node $p$, and $p_1,p_2$ are two child nodes of $p$. Vertex $w$ and $z$ are neighbors of $x$ and $y$ respectively and their core numbers are both larger than $x$'s and $y$'s. For $w$, we first locate $p_w$ that $w$ belongs to and trace up to find $p_1$ which is the ancestor node of $p_w$ as well as one child node of $p$. Thus the value of $w$ in this map is $p_1$. Similarly, $p_2$ is mapped to $z$.
\end{example}
After traversing the subtree and building the map, we can now reorganize vertices in $p$ by enumerating their neighbors. For instance, $p_1$ is now associated with $x$ because $x$ has a neighbor $w$. If $p_1$ is associate with another vertex in $p$, then we can group this vertex with $x$ in one vertex set because they are connected through some vertices of the subtree whose root is $p_1$. Note that if we find one of $x$'s neighbor vertices whose core number is equal to $x$'s, we can directly group it with $x$ because this vertex is definitely being in $p$ as well. 
After reorganizing vertices in $p$, we can determine whether the node should be split. Note that the maximum number of nodes that $p$ may be split to is 2 (recall Lemma~\ref{lemma:relevantNode}), if vertices in $p$ are eventually grouped in two sets, then we split this node and repeat the process in $p.father$. 
The terminating condition of spliting the subtree is all the vertices of $p$ are grouped in one set and all the child nodes of $p$ are shared by vertices in this set. We give Example~\ref{em:steps} to illustrate the process.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{figures/steps}
    \caption{The process of spliting the subtree.}
    \label{fig:steps}
\end{figure}

\begin{example}
\label{em:steps}
Consider the original graph in Figure~\ref{fig:split2}, the process of spliting the subtree is shown in Figure~\ref{fig:steps}. After delete the edge ($G,I$), we first locate the node $p_3$ contains $G$, reorganize vertices of $p_3$ and find that $p_2$ is associate with no vertex of $p_3$. Although $p_3$ remains complete, we continue the process in $P_4$. Then, after reorganizing vertices in $p_4$, we split it to two nodes because $p_2$ and $p_3$ are respectively shared by vertices $H$ and $M$. Next, $p_5$ remains unaffected and all its child nodes are shared by $N$ in $p_5$. Finally we finish spliting the subtree.  
\end{example}

%If $p$ is split to 2 nodes then we continue the process in $p.father$ until no node needs to be split.
%Note that we separate the node from the one whose has more vertices because it is more efficient.



\textbf{Step 3: Move up vertices of $V^-$.}

After computing the vertex set $V^-$ and modifying the structure of the tree index, the third step of our edge deletion algorithm is moving up vertices of $V^-$ if necessary. We give the {\tt moveUp} algorithm in Algorithm~\ref{alg:moveUp}.

As outlined in Algorithm~\ref{alg:moveUp}, we first initialize two node sets $P,P'$(line 3). We need to remove $V^-$ from $vertexSet$ of $p$ and update $invertedList$ of $p$ (line 4). Then if the core number of $father$ is $c-1$, we add $V^-$ to it; If the core number of $father$ is less than $c-1$, we create a new node and join it to the tree(lines 5-10). Next, we collect the left vertices of $p$ in $set$, reorganize and split them to nodes and update the vertex-node map (lines 11-13). We also need to update $childList$ and $invertedList$ of $p.father$ (lines 15-16). If there exist child nodes that are not visited in line 12, we re-link them to $p.father$ because these nodes are traceable only by vertices of $V^-$ (lines 16-18).


\begin{algorithm}[h]
\caption{move up vertices: {\tt moveUp}}
\label{alg:moveUp}
\footnotesize{
\algrenewcommand{\algorithmiccomment}[1]{\hskip3em$//$ #1}
\begin{algorithmic}[1]
\Function{moveUp($V^-$, $p$)}{}
\If{$V^- \neq \emptyset$}
    \State $P,P'\gets \emptyset$;
    \State update $p$;
    \If{ $ (p.father).getCore$ = $c$-1}
    %\If{$father.getCore = c-1$}
       \State add $V^-$ to $father$;
    \Else
       \State create new node $newFather$;
       \State add $V^-$ to $newFather$;
       \State join $newFather$ to the tree;
    \EndIf
  \State $set \gets$ $p.vertexSet$;
  \State $P \gets$ reorganize vertices of $set$ and split to nodes;
  \State update vertex-node map;
  \State link each $p_i \in P$ to $p.father$;
  \State update $invertedList$ of $p.father$;

  \State $P' \gets$ get child nodes which are not visited by the re-oranize step;
  \If{$P' \neq \emptyset$}
    \State re-link each $p \in P'$ to $p.father$;
  \EndIf
\EndIf
\EndFunction
\end{algorithmic}}
\end{algorithm}


We outline the edge deletion algorithm in Algorithm~\ref{alg:delete}. Similar to edge insertion, we have three cases to handle separately. In these three cases, we first compute vertex set $V^-$ (lines 3,8,13). Then we split the subtree (lines 4,9,14). Next we apply {\tt moveUp} to update vertices of $V^-$ (lines 6,11,17). In $p_u=p_v$ case, if the tree is split to 2 parts, we should separate $V^-$ to two sets and invoke {\tt moveUp} accordingly (lines 19-21).

\begin{algorithm}[h]
\caption{index algorithm: {\tt deleteEdge}}
\label{alg:delete}
\footnotesize{
\algrenewcommand{\algorithmiccomment}[1]{\hskip3em$//$ #1}
\begin{algorithmic}[1]
\Function{deleteEdge($p_u,p_v$)}{}
    \If{$p_u.coreNum > p_v.coreNum$}
        \State compute $V^-$ in $p_v.vertexSet$;
        \State split the subtree;
        \State locate node $p_v'$;
        \State \Call{moveUp($V^-$,$p_v'$)}{};
    \ElsIf{$p_u.coreNum < p_v.coreNum$}
        \State compute $V^-$ in $p_u.vertexSet$;
        \State split the subtree;
        \State locate node $p_u'$;
        \State \Call{moveUp($V^-$,$p_u'$)}{};
    \Else
        \State compute $V^-$ in $p_u.vertexSet$;
        \State split the subtree;
        \State locate node $p_u',p_v'$;
        \If{$p_u' = p_v'$}
             \State \Call{moveUp($V^-$,$p_u'$)}{};
        \Else
             \State ${V_u}^-, {V_v}^- \gets$ separate $V^-$;
             \State \Call{moveUp(${V_u}^-$,$p_u'$)}{};
             \State \Call{moveUp(${V_v}^-$,$p_v'$)}{};
        \EndIf

    \EndIf
\EndFunction
\end{algorithmic}}
\end{algorithm}


