\section{Details of the Advanced Method}
\label{app-advanced}

\begin{algorithm}[h]
\caption{Index construction: {\tt advanced}}
\label{alg:advancedIndex}
\footnotesize{
\algrenewcommand{\algorithmiccomment}[1]{\hskip3em$//$ #1}
\begin{algorithmic}[1]
\Function{buildIndex($G(V,E)$)}{}
        \State $core_G[\text{ }]\gets$ $k$-core decomposition on $G$;
        \For {each $v\in V$}
            \Call{makeSet($v$)}{};
        \EndFor
        \State put vertices into sets $V_0, V_1, \cdots, V_{k_{max}}$;
        \State $k\gets k_{max}$, $map\gets \emptyset$;
        \While {$k\geq 0$}
            \State $V'\gets \emptyset$;
            \For {each $v\in V_k$}
                $V'$.add(\Call{find($v$)}{});
            \EndFor
            \State compute connected components for $V_{k}\cup V'$;
            \For {each component with vertex set $C_i$}
                \State create a node $p_i$ using ($k$, $\{C_i-V'\}$);
                \For {each $v \in \{C_i-V'\}$}
                    %\State $invertArr[v]\gets p_i$;
                    \State $map$.add($v$, $p_i$);
                    \For {each $ u \in v$'s neighbor vertices}
                        \If {$core_G[u]\geq core_G[v]$}
                            \State \Call{union($u$, $v$)}{};
                        \EndIf
                        \If {$core_G[u]>core_G[v]$}
                            \State $uRoot\gets$\Call{find($u$)}{};
                            \State $uAnchor\gets uRoot.anchor$;
                            %\State $p'\gets invertArr(uAnchor)$;
                            \State $p'\gets$ $map$.get($uAnchor$);
                            \State add $p'$ to $p$'s child List;
                        \EndIf
                    \EndFor
                    \State $vRoot\gets$\Call{find($v$)}{};
                    \If {$core_G[vRoot.anchor] > core_G[v]$}
                        \State \Call{updateAnchor($vRoot$, $core_G[\text{ }]$, $v$)}{};
                    \EndIf
                \EndFor
            \EndFor
            \State $k\gets k-1$;
        \EndWhile
        \State build the root node $root$;
        \State build an inverted list for each tree node;
        \State \Return $root$.
\EndFunction
\end{algorithmic}}
\end{algorithm}

Algorithm~\ref{alg:advancedIndex} presents the {\tt advanced} method.
Similar with {\tt basic} method, we first conduct $k$-decomposition (line 2).
Then, for each vertex, we initialize an AUF tree node (line 3).
We group all the vertices into sets (line 4),
where set $V_k$ contains vertices with core numbers being exactly $k$ (line 5).
Next, we initialize $k$ as $k_{max}$ and the vertex-node map $map$,
where the key is a vertex and the value is a CL-tree node whose vertex set contains this vertex.
In the while loop (lines 6-25),
we first find the set $V'$ of the representatives for vertices in $V_k$,
then compute the connected components for vertex set $V_k\cup V'$ (lines 7-9).
Next, we create a node $p_i$ for each component (lines 10-11).
For each vertex $v\in \{C_i-V'\}$, we add a pair ($v$, $p_i$) to the $map$ (lines 12-13).
Then for each of $v$'s neighbor, $u$, if its core number is at least $core_G[v]$,
we link $u$ and $v$ together in the AUF by a \textsc{union} operation (lines 14-16),
and find $p_i$'s child nodes using the anchor of the AUF tree (lines 17-21).
After vertex $v$ has been added into the CL-tree, we update the anchor (lines 22-24).
Then we move to the upper level in next loop (line 25).
After the while loop, we build the root node of the CL-tree (line 26).
Finally, we build the inverted list for each tree node and obtain the built index (lines 27-28).


\textbf{Complexity analysis.}
In Algorithm~\ref{alg:advancedIndex}, lines 1-3 can be completed in $O(m)$ (We assume $m$>$n$).
In the while loop, the number of operations on each vertex and its neighbors are constant,
and each can be done in $O(\alpha(n))$, where $\alpha(n)$ is the inverse Ackermann function.
The keyword inverted lists of all the tree nodes can be computed in $O(n\cdot {\widehat l})$.
Therefor, the CL-tree can be built in $O(m\cdot \alpha(n)+n\cdot{\widehat l})$.
The space cost is $O(m+n\cdot{\widehat l})$, as maintaining an AUF takes $O(n)$.

