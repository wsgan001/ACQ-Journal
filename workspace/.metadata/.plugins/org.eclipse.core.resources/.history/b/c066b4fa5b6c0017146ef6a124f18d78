package algorithm.FPTreeAlgo;

import java.util.*;

/**
@author chenyankai
@Date	Jul 19, 2017

This is an implementation of the FPMax algorithm (Grahne et al., 2004).
High Performance Mining of Maximal Frequent Itemsets (with J. Zhu).
*/
public class FPMax {
//use core number of k-core as the minSup: miniSup=k+1
 private int minSup=-1;
 private MFPTree mfpTree=null;
	
	public FPMax(int k){
		this.minSup=k+1;
		this.mfpTree=new MFPTree(k);
	}
	
	
	
	public void fpMax(FPTree fpTree){
		//get the result of single path property 
		//and get the support of the single path if there exists one
		FPNode root=fpTree.getRoot();
		int[] result=fpTree.isSingleAndMiniSup(root);
		boolean singlePath=result[0]==1? true:false;
		int singlePathSup=result[1];
		
		//case 1:the FPtree contains a single path
		if(singlePath && singlePathSup>=minSup){
			mfpTree.insert(itemset, singlePathSup);
		}
		
		
		
		
		//case 2: the fptree contains more than a single path 
		
		
	}
	
	
//index 0:mark the single property: 1 means single; 
//index 1: record the support of the single path if there exists one
//index 2~ , records the path if it is a single path 	
	private List<Integer> isSingleAndMinSup(FPTree tree){
		FPNode root=tree.getRoot();
		List<Integer> result=new LinkedList<Integer>();
		result.add(1);
		if(root.getChild().size()==0) {
			result.set(0, 0);
			return result;
		}
		
		while(root.getChild().size()!=0){
			if(root.getChild().size()!=1) {
				result.set(0, 0);
				break;
			}
			root=root.getChild().iterator().next();
			// index 1: update the support
			if(result.size()==1) result.add(root.getCount());
			else result.set(1, root.getCount());
		}
		return result;
	}
	
	
	public static void main(String[] atgs){
		List<Integer> list=new LinkedList<Integer>();
		list.add(0);
		list.add(1);
		list.add(2);
		for(int x:list) System.out.println(x);
	}
	
}
