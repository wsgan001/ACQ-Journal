import math
import numpy as np
from scipy.stats import norm
from timeit import default_timer as timer #for timing

def d1BS(S, K, T, t, sigma, q, r):
    return (    math.log(S / K) + (r - q) * (T - t)) / (sigma * math.sqrt(T - t)) \
        + 0.5*sigma * math.sqrt(T - t) 
        
def d2BS(S, K, T, t, sigma, q, r):
    return (math.log(S /K) + (r - q) * (T - t)) / (sigma * math.sqrt(T - t))\
         -0.5* sigma * math.sqrt(T - t)

#black-scholes func for call option
def CBS(S, K, T, t, sigma, q, r):
    return S * math.exp((-q) * (T - t)) * norm.cdf(d1BS(S, K, T, t, sigma, q, r))\
         - K * math.exp((-r) * (T - t)) * norm.cdf(d2BS(S, K, T, t, sigma, q, r))

#black-scholes func for put option
def PBS(S, K, T, t, sigma, q, r):
    return K * math.exp(-r * (T - t)) * norm.cdf(-d2BS(S, K, T, t, sigma, q, r))\
         - S * math.exp(-q * (T - t)) * norm.cdf(-d1BS(S, K, T, t, sigma, q, r))
         
#Initiate guess of sigma in newton method
def initGuess(S, K, T, t, q, r):
    return math.sqrt(2 * abs( (math.log(S / K) + (r - q) * (T - t)) / (T - t)))

#Implied volatility for call option
def implied_vol_C(S, K, t, T, q, r, cTrue):
    tol = 1e-8
    sigma = initial_guess(S, K, t, T, q, r)
    sigmaDiff = 1.0
    n = 1
    nMax = 1000
    while sigmaDiff >= tol and n < nMax :
        #f(xn)
        c = call_black_scholes(S, K, t, T, sigma, q, r)
        fn = c - cTrue
        #f'(xn)
        fn1 = S * math.exp((0 - q) * (T - t)) * math.sqrt(T - t) * norm._cdf(dOne(S,K,t,T,sigma, q, r))
        increment = fn / fn1 * 0.1
        sigma = sigma - increment
        n += 1
        sigmaDiff = abs(increment)
    return sigma