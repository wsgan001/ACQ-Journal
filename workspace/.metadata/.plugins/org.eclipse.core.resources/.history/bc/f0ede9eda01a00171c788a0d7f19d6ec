import math
import numpy as np
from scipy.stats import norm
from timeit import default_timer as timer #for timing

def dBS(S, K, T, t, sigma, q, r, type):
    if type=='d1':
        return (    math.log(S / K, math.e) + (r - q) * (T - t)) / (sigma * math.sqrt(T - t)) \
        + 0.5*sigma * math.sqrt(T - t) 
    elif type=='d2':
        return (math.log(S /K, math.e) + (r - q) * (T - t)) / (sigma * math.sqrt(T - t))\
         -0.5* sigma * math.sqrt(T - t)
     else:
        print "error"   

#black-scholes func for call/put option
def BS(S, K, T, t, sigma, q, r,type):
    if type=='C':
        return S * math.exp((-q) * (T - t)) * norm.cdf(dBS(S, K, T, t, sigma, q, r,'d1'))\
         - K * math.exp((-r) * (T - t)) * norm.cdf(dBS(S, K, T, t, sigma, q, r,'d2'))
    elif type=='P':
        return K * math.exp(-r * (T - t)) * norm.cdf(-dBS(S, K, T, t, sigma, q, r,'d2'))\
         - S * math.exp(-q * (T - t)) * norm.cdf(-dBS(S, K, T, t, sigma, q, r,'d1'))
    else:
        print "error"
    
         
#Initiate guess of sigmahat with newton method
def initGuess(S, K, T, t, q, r):
    return math.sqrt(2 * abs( (math.log(S / K, math.e) + (r - q) * (T - t)) / (T - t)))

#Implied volatility for call option
def IVC(S, K, T, t, q, r, cTrue):
    lowBound = 1e-8
    sigma = initGuess(S, K, T, t, q, r)
    sigmaDiff = 1.0
    n = 1
    nMax = 1000
    while sigmaDiff >= lowBound and n < nMax :
        #f(xn)
        c = BS(S, K, T, t, sigma, q, r, 'C')
        fn = c - cTrue
        #f'(xn)
        fn1 = S * math.exp((-q) * (T - t)) * math.sqrt(T - t) * norm._cdf(dBS(S,K,T,t,sigma,q,r,'d1'))
        increment = fn / fn1 * 0.1
        sigma = sigma - increment
        n += 1
        sigmaDiff = abs(increment)
    return sigma

def IVP(S, K, T, t, q, r, cTrue):
    return 

#risk free
def d(S, K, T, sigma, mu,type):
    if type=='d1':
        return (math.log(S/K, math.e)+(mu+0.5*pow(sigma, 2))*T)/(math.sqrt(T)*sigma)
    elif type=='d2':
        return (math.log(S/K, math.e)+(mu-0.5*pow(sigma, 2))*T)/(math.sqrt(T)*sigma)
    else:
        print "error"

#Geometric Asian option
def geoAsianOption(S, sigma, r, t, K, n, type):
    N = float(n)
    T = float(t)
    sigmaHat = sigma*math.sqrt((N+1)*(2*N+1)/(6*pow(N,2)))
    muHat = (r-0.5*pow(sigma, 2))*(N+1)/(2*N)+0.5*pow(sigmaHat, 2)

    d1 = d(S, K, T, sigmaHat, muHat,'d1')
    d2 = d(S, K, T, sigmaHat, muHat,'d2')

    if type == 'C':
        return math.exp(-r*T)*(S*math.exp(muHat*T)*norm.cdf(d1) - K*norm.cdf(d2))
    elif type=='P':
        return math.exp(-r * T) * (-S * math.exp(muHat * T) * norm.cdf(-d1) + K * norm.cdf(-d2))
    else:
        print "error"

#Geometric basket
#Input S1 S2 sigma1 simga2 r T K corr type
def geoBasket(S1, S2, sigma1, sigma2, r, T, K ,corr, type):
    sigma = math.sqrt(sigma1 ** 2 + sigma1 * sigma2 * corr * 2 + sigma2 ** 2) / 2
    mu = r-(pow(sigma1, 2)+pow(sigma2, 2))/4+0.5*pow(sigma, 2)
    B = math.sqrt(S1*S2)
    d1 = d(B, K, T, sigma, mu,'d1')
    d2 = d(B, K, T, sigma, mu,'d2')
    if type == 'C':
        return math.exp(-r*T)*(B*math.exp(mu*T)*norm.cdf(d1)-K*norm.cdf(d2))
    elif type == 'P':
        return math.exp(-r*T)*(-B*math.exp(mu*T)*norm.cdf(-d1)+K*norm.cdf(-d2))
    else:
        print "error"




