package algorithm.basic;

import java.util.*;

import javax.swing.ListModel;

import algorithm.DecomposeKCore;
import algorithm.FindCKCore;
import algorithm.ProfiledTree.*;
import config.Config;

/**
@author chenyankai
@Date	Aug 24, 2017

*/
public class BFS {
	private int[][] graph = null;
	private int[][] nodes = null;
	private int core[] = null;
	private int queryId= -1;
	private PTree pTree = null;
	private Map<Integer, PNode> pTreeMap=null;

	private Map<Set<Integer>, int[]> output=null;

	private boolean DEBUG = true;
	
	
	public BFS(int[][] graph, int[][] nodes){
		this.graph=graph;
		this.nodes=nodes;
		DecomposeKCore kCore=new DecomposeKCore(this.graph);
		core=kCore.decompose();
		this.pTree=new PTree();
		this.output=new HashMap<Set<Integer>, int[]>();
	}
	
	public void query(int queryId){
		this.queryId = queryId;
		if(core[queryId]<Config.k){
			System.out.println("No qualified connected k-core!");
			return;
		}
	
		//step 1:find the connected k-core containing queryId
		FindCKCore findCKCore=new FindCKCore();
		Set<Integer> CKC=findCKCore.findCKC(graph, core, queryId);
		if(CKC.size()<Config.k+1) return; 
		
		//------------------------DEBUG------------------------------
				if(DEBUG){
					for(int x:CKC) {
						String append="CKC users: "+x+" shared items: ";
						for(int y:nodes[x]) append+=y+" ";
						System.out.println(append);
					}
				}
		//----------------------END DEBUG----------------------------
	
		//step 2: mining all maximal common subsequences
		pTreeMap=pTree.buildPtree(nodes[queryId]);

		int[] seqStart={nodes[queryId][0]};
		List<int[]> currentPattern = new ArrayList<int[]>();
		List<Set<Integer>> currentUsers = new ArrayList<Set<Integer>>();
		currentPattern.add(seqStart);
		currentUsers.add(CKC);
		BFSMine(currentPattern, currentUsers);
		
		
	}
	
	private void BFSMine(List<int[]> currentPattern,List<Set<Integer>> currentUsers){
		
		while(!currentPattern.isEmpty()){
			List<int[]> nextPattern = new ArrayList<int[]>();
			for(int[] pattern:currentPattern){
				List<int[]> nextSeqList = geneSubtree(pattern);
				if(nextSeqList.size()==0){
					
				}
				
			}
			
			
		}
	}
	
	
	//generate a new subtree from a subtree by add an node in the right most path
	private List<int[]>  geneSubtree(final int[] seq){
		List<Integer> rightmostPath=getRightmostPath(seq);
		//------------------------DEBUG------------------------------
		if(DEBUG) System.out.println("now rightmost path:"+rightmostPath.toString() );
		//----------------------END DEBUG----------------------------
		
		List<int[]> nextSeq=new ArrayList<int[]>();
		for(int i=0;i<rightmostPath.size()-1;i++){
			int father=rightmostPath.get(i);
			int child=rightmostPath.get(i+1);
			List<PNode> childSet=pTreeMap.get(father).getChildlist();
			if(child<childSet.get(childSet.size()-1).getId()){
				for(PNode node:childSet){
					int x=node.getId();
					if(x>child){
						int[] b=new int[seq.length+1];
						System.arraycopy(seq, 0, b, 0, seq.length);
						b[b.length-1]=x;
						nextSeq.add(b);
						//------------------------DEBUG------------------------------
						if(DEBUG){
							System.out.print("new Array: ");
							for(int q:b) {
								System.out.print(q+" ");
							}
							System.out.println();
						}
						//----------------------END DEBUG----------------------------
					}
				}
			}
		}
		//last node of in the right most path
		int lastOne=rightmostPath.get(rightmostPath.size()-1);
		List<PNode> childSet=pTreeMap.get(lastOne).getChildlist();
			for(PNode node:childSet){
				int x=node.getId();
					int[] b=new int[seq.length+1];
					System.arraycopy(seq, 0, b, 0, seq.length);
					b[b.length-1]=x;
					nextSeq.add(b);
					//------------------------DEBUG------------------------------
					if(DEBUG){
						System.out.println("poteintial new seq: ");
						for(int q:b) {
							System.out.print(q+" ");
						}
						System.out.println();
					}
					//----------------------END DEBUG----------------------------
			}
			
		//------------------------DEBUG------------------------------
		if(DEBUG) System.out.println("next rightmost path number:"+nextSeq.size());
		//----------------------END DEBUG----------------------------	
		return nextSeq;
	}
	
	//calculate the right most path of one tree
	//get the rightmost path of one subtree pattern
	private List<Integer> getRightmostPath(final int[] seq){
		return pTree.tracePath(seq[seq.length-1]);
	}
	
	
}
