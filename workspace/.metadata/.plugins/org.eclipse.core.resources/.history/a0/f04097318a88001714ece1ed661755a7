package algorithm.basic;

import java.util.*;

import algorithm.DecomposeKCore;
import algorithm.FindCKCore;
import algorithm.ProfiledTree.*;
import config.Config;

/**
@author chenyankai
@Date	Aug 24, 2017

*/
public class BFS {
	private int[][] graph = null;
	private int[][] nodes = null;
	private int core[] = null;
	private int queryId= -1;
	private PTree pTree = null;
	private Map<Integer, PNode> pTreeMap=null;

	private Map<Set<Integer>, int[]> output=null;

	private boolean DEBUG = true;
	
	
	public BFS(int[][] graph, int[][] nodes){
		this.graph=graph;
		this.nodes=nodes;
		DecomposeKCore kCore=new DecomposeKCore(this.graph);
		core=kCore.decompose();
		this.pTree=new PTree();
		this.output=new HashMap<Set<Integer>, int[]>();
	}
	
	public void query(int queryId){
		this.queryId = queryId;
		if(core[queryId]<Config.k){
			System.out.println("No qualified connected k-core!");
			return;
		}
	
		//step 1:find the connected k-core containing queryId
		FindCKCore findCKCore=new FindCKCore();
		Set<Integer> CKC=findCKCore.findCKC(graph, core, queryId);
		if(CKC.size()<Config.k+1) return; 
		
		//------------------------DEBUG------------------------------
				if(DEBUG){
					for(int x:CKC) {
						String append="CKC users: "+x+" shared items: ";
						for(int y:nodes[x]) append+=y+" ";
						System.out.println(append);
					}
				}
		//----------------------END DEBUG----------------------------
	
		//step 2: mining all maximal common subsequences
		
		
	}
	
	
	
}
