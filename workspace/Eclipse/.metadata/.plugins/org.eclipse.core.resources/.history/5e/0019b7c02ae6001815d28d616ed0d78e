package EXP;

import java.util.*;
import algorithm.*;
import algorithm.ProfiledTree.PNode;
import algorithm.kwIndex.KWNode;
import config.Config;

public class otherDefinition {
	private int graph[][] = null;
	private int nodes[][] = null;
	private int queryId = -1;
	private Map<Integer,KWNode> subKWTree = null;
	private List<Integer> leafList = null;

	

	public void mostPaths(int [][] graph, int node[][]){
		this.graph = graph;
		this.nodes = node;
			
	}
	
	public Set<Integer> query(int queryId){
		Set<Integer> set =new HashSet<Integer>();
		this.queryId = queryId;
		boolean state = induceKWTree();
		if(!state) return;
		
		if(graph[queryId].length < Config.k)   return set;
		
		//step 1: find k-core first
		FindKCore fkc = new FindKCore(graph, Config.k);
		int subCore[] = fkc.decompose();
		
		//step 2: find ck-core
		FindCKCore finder = new FindCKCore();
		Set<Integer> rsSet = finder.findCKC(graph, subCore, queryId);
		
		//step 3: find the community with most paths
		if(rsSet.size()>1){
			set = findMostPath(rsSet);
			
			
			
			return set;
		}
		else{
			return set;
		}
	}
	
	private boolean induceKWTree(){
		this.subKWTree = new HashMap<Integer,KWNode>();
		this.leafList = new LinkedList<Integer>();
		Map<Integer, List<Integer>> childMap = new HashMap<Integer, List<Integer>>();
		KWNode root = new KWNode(1);
		subKWTree.put(1, root);
		int maxLength = 0;
		for(KWNode currentNode:headList.get(queryId)){
			//to mark the leaf item in the induce subKWtree
			int leaf = -1;
			int countLength = 0;
			boolean first = true;
			if(currentNode==null) continue;
			while(currentNode.itemId != 1){
				Set<Integer> vertexSet = currentNode.getCKCore(k, queryId);
//				if(vertexSet.isEmpty()) System.out.println("Not include id: "+currentNode.itemId);
				if(!vertexSet.isEmpty()){
					int currenItem = currentNode.itemId;
					if(!subKWTree.containsKey(currenItem)){
						KWNode newNode = new KWNode(currenItem);
						newNode.tmpVertexSet = vertexSet;
						subKWTree.put(currenItem, newNode);
						//computing the length of the current path
						countLength++;
						
						if(first){
							leaf = currenItem;
							first = false;
						}
					}
					
					List<Integer> child = childMap.get(currentNode.father.itemId);
					if(child==null){
						child = new ArrayList<Integer>();
						child.add(currenItem);
						childMap.put(currentNode.father.itemId, child);
					}else{
						child.add(currenItem);
					}
				}
				currentNode = currentNode.father;
			}
			if(countLength > maxLength) {
				maxLength = countLength;
			}
			if(subKWTree.containsKey(leaf)) leafList.add(leaf);
		}
		
		Iterator<Integer> iter = childMap.keySet().iterator();
		while(iter.hasNext()){
			int father = iter.next();
			KWNode fatherNode = subKWTree.get(father);
			if(fatherNode==null) {
				System.out.println("father is null: "+father);
				continue;
//				return false;
			}
 			for(int child:childMap.get(father)){
				subKWTree.get(child).father = fatherNode;	
				fatherNode.childList.add(subKWTree.get(child));
			}
		}		
		return true;
	}
	
	
	
	public Set<Integer> findMostPath(Set<Integer> set){
		Set<Integer> users = new HashSet<Integer>(); 
		Queue<Set<Integer>> patternQueue = new LinkedList<Set<Integer>>();
		Set<Integer> startPattern = new HashSet<Integer>();
		startPattern.add(1);
		patternQueue.add(startPattern);
		
		while(!patternQueue.isEmpty()){
//			System.out.println(patternQueue.size());
			Set<Integer> patternToCheck = patternQueue.poll();
			
			//if already reach the maximum pattern then return
			if(patternToCheck.size()==nodes[queryId].length){
				maximalPattern.add(patternToCheck);
				continue;
			}
			
			List<Integer> RMPath = getRMPath(patternToCheck);
			for(int x:RMPath){
				for(PNode node:pTreeMap.get(x).getChildlist()){
					int newItem = node.getId();
					if(!patternToCheck.contains(newItem)){
						Set<Integer> newPattern = new HashSet<Integer>();
						newPattern.addAll(patternToCheck);
						newPattern.add(newItem);
						
						Set<Integer> newUsers = obtainNewUsers(newPattern);
						if(!newUsers.isEmpty()){
							patternQueue.add(newPattern);
						}else{
							checkMax(patternToCheck);
						}
						
					}
					
				}
			}	
		}
			
		return users;
	}
	
	
	
	
	public boolean checkisMostPaths(Set<Integer> pattern){
		
		Set<Integer> leaves = new HashSet<Integer>();
		leaves.addAll(pattern);
		
		Iterator<Integer> it = pattern.iterator();
		while(it.hasNext()){
			int item = it.next();
			int itemFather = subKWTree.get(item).father.itemId;
			if(pattern.contains(itemFather)) leaves.remove(itemFather);
		}
		return leaves;
		
		
		
		
	}
	
	
	
	
}
